# -*- coding: utf-8 -*-
"""My_Neural_Network_Class.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CcMclkPchtbS1kPmRyvu9m32O4pMpZ4f
"""

import numpy as np

RELU = "relu"
SIGMOID = "sigmoid"

def relu(x, deriv=False):
    if deriv:
      return x > 0
    return (x > 0) * x

def sigmoid(x, deriv=False):
  if deriv:
    return x*(1-x)
  return 1 / (1 + np.exp(-x))

class NeuralNetwork:
  def __init__(self):
    np.random.seed(1)
    self.layers = 3
    self.layers_size = np.array([3, 4, 1])
    self.epochs = 10
    self.activation_function = "RELU"
    self.alpha = 0.1
  
  def set_network(self, layers: int, layers_size: np.array, epochs: int, activation_function = RELU, alpha=0.1):
    self.layers = layers
    self.layers_size = layers_size
    self.epochs = epochs
    self.activation_function = activation_function
    self.alpha = alpha
  
  def Af(self, x, deriv = False):
    if self.activation_function == SIGMOID:
      return sigmoid(x, deriv)
    return relu(x, deriv=deriv)
 
  def train(self, input, output, info_print=False):
    self.weights = []
    for i in range(self.layers-1):
      self.weights.append(2*np.random.random((self.layers_size[i], self.layers_size[i+1])) - 1)
    self.weights = np.array(self.weights)

    data_size = len(input)
    loss_error = 0
    for iteration in range(self.epochs):
      final_error = 0
      for i in range(data_size):
        layer_data = []
        for layer in range(self.layers):
          # Forward Process
          if layer == 0:
            layer_data.append(np.array(input[i:i+1]))
          elif layer > 0 and layer < self.layers - 1:
            layer_data.append(self.Af(np.dot(layer_data[layer-1], self.weights[layer-1])))
          elif layer == self.layers - 1:
            layer_data.append(np.dot(layer_data[layer-1], self.weights[layer-1]))
 
            # Backpropagation
            # Calculate Errors
            b_index = self.layers - 1
            delta_error = []
            for b_layer in range(self.layers - 1):
              #print(b_index)
              #print(b_layer)
              if b_layer == 0:
                delta_error.append(layer_data[b_index] - output[i:i+1])
                final_error += delta_error[b_layer] ** 2
                #print(delta_error[b_layer])
              else:
                delta_error.append(np.dot(delta_error[b_layer-1], self.weights[b_index].T) * self.Af(layer_data[b_index], deriv=True))
              b_index -= 1

            # Calculate New Weights
            b_index = self.layers - 1
            w_index = self.layers - 2
            for b_layer in range(self.layers - 1):
              layer_prev = np.array(layer_data[b_index-1]).T
              layer_delta_curr = delta_error[b_layer]
              self.weights[w_index] -= self.alpha * np.dot(layer_prev, layer_delta_curr)
              b_index -= 1
              w_index -= 1
      if info_print and iteration % 10 == 9:
        print("\n")
        print("Error: %.2e" % final_error)
        for i in range(self.layers-1):
          print("Weights_%d:" % i + str(self.weights[i]))
      loss_error = final_error

    loss_size = len(loss_error.T)
    print("\n")
    for i in range(loss_size):
      print("LOSS ERROR_%d" % i + " = %0.2e" % loss_error.T[i])

      
  def test(self, input):
    output = input
    for i in range(self.layers-1):
      output = np.dot(output, self.weights[i])
    return output

if __name__ == "__main__":
  streetlight = np.array( [ [1, 0, 1],
                            [0, 1, 1],
                            [0, 0, 1],
                            [1, 1, 1],
                            [1, 1, 0],
                            [1, 0, 0]] )

  walk_vs_stop = np.array([[1,0], [0,1], [0,0], [1,1], [1,1], [1,0]])

  nn = NeuralNetwork()
  nn.set_network(layers=2, layers_size=np.array([3,2]), epochs=100, activation_function=RELU, alpha=0.2)
  nn.train(streetlight, walk_vs_stop, info_print=False)

  loop = True
  while loop:
    print("\n")
    A = input("A (0 or 1) =  ")
    B = input("B (0 or 1) =  ")
    C = input("C (0 or 1) =  ")

    if (A == "0" or A == "1") and (B == "0" or B == "1") and (C == "0" or C == "1"):
      test_input = np.array([[int(A), int(B), int(C)]])
      output = nn.test(test_input)

      output_size = len(output.T)
      print("\n")
      for i in range(output_size):
        print("Output_%d" % i + " = %0.2f" % output.T[i])

    else:
      loop = False